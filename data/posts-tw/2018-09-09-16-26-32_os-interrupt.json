{
  "guid": "http://blog.wildsky.cc/?p=75",
  "date": "2018-09-09T16:26:32",
  "slug": "os-interrupt",
  "link": "/posts/os-interrupt/",
  "title": "作業系統 Ch2-1 &#8211; interrupt",
  "excerpt": "<p>最近在看 清大開放課程作業系統 還債XD 上次看的這次就忘了，所以想來記筆記，幫助未來自己不用再重看影片。 這&#8230;</p>\n",
  "feature_image_url": "https://backend.wildsky.cc/wp-content/uploads/2018/09/markus-spiske-666905-unsplash-e1553233600406.jpg",
  "content": "\n<p>最近在看 <strong>清大開放課程作業系統</strong> 還債XD 上次看的這次就忘了，所以想來記筆記，幫助未來自己不用再重看影片。</p>\n\n\n\n<p>這次看的是關於 interrupt 的部分，探討作業系統如何做到 event-driven，避免 CPU 一直在空轉或 idle。</p>\n\n\n\n<!--more-->\n\n\n\n<h2>重點</h2>\n\n\n\n<ul><li>interrupt 的流程（軟硬體）</li><li>什麼是 interrupt vector &amp; interrupt routine</li><li>為什麼要記住被打斷的 instruction 的 address</li></ul>\n\n\n\n<h2>內容</h2>\n\n\n\n<ol><li>Busy/Wait output</li><li>interrupt I/O</li></ol>\n\n\n\n<h3>Busy/Wait output</h3>\n\n\n\n<p>一開始想讓電腦讀資料並處理他，最直覺就是會用這種方式，讓 CPU 一直去看 I/O 好了沒，還沒好就繼續問，問到他好了為止。但這樣做的缺點也很明顯，CPU 要忙著問進度沒辦法去做其他事情，程式在運作時仍會霸佔著 CPU，沒有辦法 multiprogramming。</p>\n\n\n\n<p>程式碼大概長得像這樣：</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// 讀檔\nvar file = file.open('file1.txt');\n\nwhile(EOF) {\n  read_char(file);\n  while (peek_read_status());\n  current_char++;\n}</code></pre>\n\n\n\n<p>但因為太浪費 CPU 資源了，所以又有了下面這個新的方法。</p>\n\n\n\n<h3>Interrupt I/O</h3>\n\n\n\n<p>這個方法就是 CPU 把自己變成更高層的老闆，然後要各部長去叫他的部員處理事情，處理完了部長再跟他說。等待的期間老闆就可以自己去找其他事做。</p>\n\n\n\n<p>特點有三：</p>\n\n\n\n<ul><li>現在的電腦都是這個架構</li><li>a.k.a event-driven</li><li>interrupt 可以改變 CPU 執行的 flow</li></ul>\n\n\n\n<p>基本流程:</p>\n\n\n\n<ol><li>CPU 跟 Controller 說：「你來幫我讀資料，讓我可以做事情 A，做完跟我說」（話音剛落，CPU 就去做其他的事情 B）</li><li>Controller 搬完資料後，就來跟 CPU 說：「事情 A 所需的資料好了，我都放在 XXX memory」</li><li>CPU 收到後就可以決定要繼續做 B，還是回去做 A，就看 CPU 的 scheduling</li></ol>\n\n\n\n<p>這個流程也會根據細節微調，像「interrupt 是由軟體還是硬體產生的」就可能有不同的流程。</p>\n\n\n\n<ul><li>hardware 產生的 interrupt 就叫做 <code>signal</code></li><li>software 的叫做 <code>trap</code>，有兩種狀況會產生<ul><li>不預期的：像是 segmentation fault 之類的，caused by <strong>error</strong></li><li>system call：所有的 system call 都是間接的，會丟出一個 interrupt 等 OS 去接，OS 想接的時候才會安排相關的 handler 去處理，完成才通知你</li></ul></li></ul>\n\n\n\n<h4>Signal: hardware interrupt 的流程</h4>\n\n\n\n<ol><li>hardware 會偵測到事情發生，對 OS 打一個 signal，並將正在執行的程式資訊記下來</li><li>OS 去查 function vector 找誰是主事者，然後 call 他（稱作 service routine）</li><li>執行完就 return，然後回去執行原本在跑的程式</li></ol>\n\n\n\n<p>P.S: function vector 的數量是跟著硬體燒死的，所以是數量固定的 array（就是 vector）</p>\n\n\n\n<h4>Trap: software interrupt 的流程</h4>\n\n\n\n<blockquote class=\"wp-block-quote\"><p>It&#8217;s a trap!</p></blockquote>\n\n\n\n<ol><li>user call 一個 system call （或是跑了個除以零的程式產生 exception）</li><li>trap 到 OS 去</li><li>查 switch case 表中要執行哪個程式</li><li>查到了就跑他</li><li>跑完就 return 到剛剛 call system call 的人身上</li></ol>\n\n\n\n<p>因為是軟體，system call 的數量是無上限的，想訂幾個就幾個，所以步驟三會用 switch case 的方式去寫。</p>\n\n\n\n<h4>共同</h4>\n\n\n\n<ul><li>兩者都要有 interrupt vector &amp; interrupt routine (handler)<br>用來對應 interrupt 和相關的 function<ul><li>interrupt vector 就是個表</li><li>interrupt rountine 就是那個被對應到的 function</li></ul></li><li>必須要記住 被打斷的 instruction 的 address<br>return 時才能 resume</li><li>之後產生的 interrupt 要能夠被 mask 掉，避免一直被打斷<br>所以就會有不同 priority 的 interrupt，處理高時就會忽略低</li></ul>\n\n\n\n<h2>Reference</h2>\n\n\n\n<ul><li><a href=\"http://ocw.nthu.edu.tw/ocw/index.php?page=chapter&amp;cid=141&amp;chid=1840&amp;video_url=http%3A%2F%2Focw.nthu.edu.tw%2Fvideosite%2Findex.php%3Fop%3Dwatch%26id%3D3911%26filename%3D1920_1080_3072.MP4%26type%3Dview%26cid%3D141%26chid%3D1840\">清大開放課程作業系統 第四講第一節</a></li></ul>\n"
}