{
  "guid": "http://blog.wildsky.cc/?p=77",
  "date": "2018-09-11T00:26:07",
  "slug": "os-storage",
  "link": "/posts/os-storage/",
  "title": "作業系統 Ch2-2 &#8211; storage",
  "excerpt": "<p>這個章節主要講電腦儲存資料的相關架構，並討論背後需要在意的問題。往後延伸到「不同的程式共用相同資源時，OS 在&#8230;</p>\n",
  "feature_image_url": "https://backend.wildsky.cc/wp-content/uploads/2018/09/markus-spiske-666905-unsplash-e1553233600406.jpg",
  "content": "\n<p>這個章節主要講電腦儲存資料的相關架構，並討論背後需要在意的問題。往後延伸到「不同的程式共用相同資源時，OS 在權限管理上 作業系統 的設計」。</p>\n\n\n\n<!--more-->\n\n\n\n<h2>儲存裝置最在意的三件事</h2>\n\n\n\n<ul><li>Speed</li><li>Cost</li><li>volatile：斷電後資料是否會遺失</li></ul>\n\n\n\n<p>越快就越貴。如果想要一台 C/P 值高的電腦，就會需要有階層的架構。</p>\n\n\n\n<h2>儲存裝置的階層</h2>\n\n\n\n<ol><li>register</li><li>cache</li><li>memory</li><li>disk</li><li>光碟</li><li>磁帶</li></ol>\n\n\n\n<p>一到六排序是由快到慢，由貴到便宜。現代還是有在用磁帶，因為比較穩，不會因為摔到或碰到水資料就整組壞光光了。</p>\n\n\n\n<p>上述的 1,2,3 屬於 main memory；4,5,6 則是 secondary storage。前者是 volatile，後者都非 volatile。</p>\n\n\n\n<p>下面分別列各自的特性：</p>\n\n\n\n<h3>Main Memory</h3>\n\n\n\n<ul><li>CPU 可直接 access 的儲存區塊（速度快）。</li><li>比較貴。</li><li>volatile</li><li>a.k.a RAM</li><li>讀取任何位置的資料，時間都是一樣的。</li><li>每次讀取速度都一致。</li><li>Disk 與之相反，會因為讀取位置不同而有不同的速度（<a href=\"http://blog.wildsky.cc/posts/os-storage/#%e7%a3%81%e7%a2%9f%e7%9a%84%e8%ae%80%e5%8f%96%e9%80%9f%e5%ba%a6\">後述</a>）。</li></ul>\n\n\n\n<h3>Secondary Storage</h3>\n\n\n\n<ul><li>速度較慢：CPU 不可直接讀，要讀要先搬進 main memory。</li><li>空間較大</li><li>比較便宜</li><li>non-volatile</li></ul>\n\n\n\n<h3 id=\"磁碟的讀取速度\">磁碟的讀取速度</h3>\n\n\n\n<p>因為是機械式的，有磁頭。<br>\n所以 <strong>資料位置和磁頭間的距離</strong> 就是造成 access 時間不同的主因。</p>\n\n\n\n<pre class=\"wp-block-code\"><code>* access time = transfer time + position time\n  * transfer time = data_size / transfer rate\n  * position time (random access time) = seek time + rotational latency</code></pre>\n\n\n\n<ul><li>seek time: 磁頭從當前位置去找資料位置的時間，可能很快也可能很慢。（硬碟說的 7200 轉、3600 轉，就是和這個有關）</li><li>所以當資料量越大（都在連續位置上），seek time 對 access 的時間就越不重要。</li></ul>\n\n\n\n<p>那階層要如何讓電腦的資料存取更快速呢？就要透過 caching。</p>\n\n\n\n<h2>快取機制 Caching</h2>\n\n\n\n<p>將資料暫時從下層複製到上層，目的是增加 access 的速度。</p>\n\n\n\n<ul><li>所有資料最終都儲存在空間最大但速度最慢的磁碟。</li><li>所以為了快一點，就會把資料往上層 copy。</li><li>實際運作：<ul><li>CPU 第一次 access 資料時，會由上往下一層一層看有無 cache，沒有就往下找，找到有為止。</li></ul><ul><li>找到後就會複製一份到上層。</li><li>所以 <em>第一次會比沒有 cache 的系統慢</em>，因為除了要一層層找之外，還要複製資料。</li><li>但第二次之後都會飛快。</li></ul></li></ul>\n\n\n\n<p>因此，有的系統就不會做 caching。</p>\n\n\n\n<p>舉例，每次都要處理大量資料的話，做 cache 就沒有意義，重讀資料還比較有效率。</p>\n\n\n\n<p>有了複製就會出現 A 改 B 沒改的狀況，也就是不一致性的問題。</p>\n\n\n\n<h2>不一致性 coherency &amp; consistency</h2>\n\n\n\n<ul><li>因為修改一定從最上層改，所以上下層可能資料不同。（不過給使用者看的一樣就好，所以其實也還好（？））</li><li>那不一致性困擾在哪？</li><li>單一程式：依照階層去做 Copy 就好，一個人時問題不大。</li><li>多個程式：要改同個資料的時候，不同程式改資料的時間可能不同⋯⋯</li><li>分散式系統：不同電腦要用同份資料⋯⋯ 大家還要資料相同⋯⋯ （還有網路問題⋯⋯）</li><li>解決的原則就是：要製造出每個程式、每台電腦使用到的資料好像都是一致的假象。</li></ul>\n\n\n\n<p>有的系統會為了效率放棄一致性。</p>\n\n\n\n<p>這邊周老師舉了 Google 搜尋結果的例子，但我自己是覺得搜尋結果的不同應該和一致性的關係較小，和個人化的關係較大。不過 Google 這個例子也有相關，忽略個人化的話各區的搜尋結果應該也還是會有差異，但我沒有證據，就只是推測就是了。</p>\n\n\n\n<p>話說回來，要怎麼讓每個程式，每台電腦都能有 <strong>看似相同</strong> 的資料呢？就是要透過 protection 了。</p>\n\n\n\n<h2>Protection</h2>\n\n\n\n<p>這裡指的不是對網路攻擊之類的 protection，比較像是各程式間對資源的 <strong>權限控管</strong>。這邊有兩個例子：</p>\n\n\n\n<ol><li>某程式 crash 時，應該要只會看到 A 程式的錯誤訊息，不會整台電腦掛掉。</li><li>某程式能改動的只有自己的 memory，要改動其他人的資料就一定要透過 OS 或 controller 才可以（就是要經過上層同意）。</li></ol>\n\n\n\n<h3>dual-mode</h3>\n\n\n\n<p>OS 要能夠區分一個 instruction 是來自 user program 還是 OS。</p>\n\n\n\n<p><strong>硬體</strong> 會提供至少兩種 mode 來支援 dual mode 的建立。</p>\n\n\n\n<ul><li><strong>User mode</strong> : user program 的行為來的。</li><li><strong>Monitor mode (kernal mode)</strong>:  OS 的行為來的。</li></ul>\n\n\n\n<p>如何區分？</p>\n\n\n\n<ul><li>硬體用一個 bit 去記錄是那個 mode（設為 isUserMode）。</li><li>平常 isUserMode = 1。</li><li>當 call 了 interrupt 就會 flip，變成 isUserMode = 0。</li><li>等 OS 跑完 return 時就會再 flip，變回 isUserMode = 1。</li><li>實作<ul><li>硬體在設計時就會有 privileged instructions 在其中。 </li></ul><ul><li>只在 monitor mode 執行（不然就會被擋住，拋出 error 給 OS 處理）</li><li>User program 就需要 call system call 來做想做的事，讓 OS 能管理。</li></ul></li><li>所以在呼叫 system call 時，一定會有下面兩件事發生：<ol><li>一開始跑時會先 flip isUserMode 的這個 bit。</li><li>跑完後再 flip 回來。</li></ol></li><li>藉由這個 dual-mode 的概念就可以延伸出下面三方面的 protection<ul><li>I/O protection</li><li>Memory protection</li><li>CPU protection</li></ul></li></ul>\n\n\n\n<p>講電腦也就都圍繞在這三件事上而已。下面來分別介紹。</p>\n\n\n\n<h3>I/O Protection</h3>\n\n\n\n<ul><li>硬體支援： <strong>所有的 I/O 都是 privileged instructions</strong>。</li><li>因為都是共用的。</li><li>只保護 I/O 是不夠的，如果沒保護 memory，就可能被竄改 interrupt vector，讓 OS 執行不該執行的程式。</li></ul>\n\n\n\n<h3>Memory Protection</h3>\n\n\n\n<ul><li>要保護下面兩種東西：</li></ul>\n\n\n\n<ol><li>interrupt vector &amp; interrupt service routine</li><li>從其他程式來的資料存取</li></ol>\n\n\n\n<ul><li>保護 2. 的實際作法：</li><li>把程式限制在一段空間中，超過就不准你亂動。</li><li>硬體支援： <strong>用兩個 register 記錄可操作的範圍</strong><ul><li>base register</li><li>limit register</li></ul></li></ul>\n\n\n\n<p>當程式要去 access memory 時就會跑這個流程：</p>\n\n\n\n<ol><li>先 load base register，看 address 有無大於開始位置。<ul><li>若小於就丟一個 trap（因為 trigger by software）</li></ul></li><li>檢查 base + limit，看 address 有無小於結束位址。</li><li>通過前面兩個判定後，才會把指令丟去 memory 的 bus，讓 memory controller 去做 data access。</li></ol>\n\n\n\n<p>所以 base register &amp; limit register 這類用於檢查的 register 都是 privileged instructions。</p>\n\n\n\n<h3>CPU Protection</h3>\n\n\n\n<ul><li>避免一隻程式一直霸佔 CPU，必須要能夠隨時把 CPU 使用權拿回來。</li><li>如何施行？<ul><li>利用 <strong>Time sharing</strong> 的概念。</li></ul></li><li>硬體支援： <strong>Timer</strong><ul><li>會一直計時，時間到就丟 interrupt，執行 OS 的 scheduler，讓他決定繼續執行 or not。</li></ul></li></ul>\n\n\n\n<p>所以 load-time 也是個 privileged instruction。（這邊的 load 是把值 load 到 timer 不是讀出來）</p>\n\n\n\n<h2>參考連結</h2>\n\n\n\n<ul><li><a href=\"http://ocw.nthu.edu.tw/ocw/index.php?page=chapter&amp;cid=141&amp;chid=1840&amp;video_url=http%3A%2F%2Focw.nthu.edu.tw%2Fvideosite%2Findex.php%3Fop%3Dwatch%26id%3D3912%26filename%3D1920_1080_3072.MP4%26type%3Dview%26cid%3D141%26chid%3D1840\">清大開放課程作業系統 第四講第二節</a></li><li><a href=\"http://ocw.nthu.edu.tw/ocw/index.php?page=chapter&amp;cid=141&amp;chid=1840&amp;video_url=http%3A%2F%2Focw.nthu.edu.tw%2Fvideosite%2Findex.php%3Fop%3Dwatch%26id%3D3913%26filename%3D1920_1080_3072.MP4%26type%3Dview%26cid%3D141%26chid%3D1840\">清大開放課程作業系統 第四講第三節</a></li><li><a href=\"http://ocw.nthu.edu.tw/ocw/index.php?page=chapter&amp;cid=141&amp;chid=1840&amp;video_url=http%3A%2F%2Focw.nthu.edu.tw%2Fvideosite%2Findex.php%3Fop%3Dwatch%26id%3D3918%26filename%3D1920_1080_3072.MP4%26type%3Dview%26cid%3D141%26chid%3D1840\">清大開放課程作業系統 第四講第四節</a></li></ul>\n\n\n\n<p>關於 作業系統 的相關筆記，可以見這裡： <a href=\"http://blog.wildsky.cc/tags/os/\">http://blog.wildsky.cc/tags/os/</a></p>\n"
}