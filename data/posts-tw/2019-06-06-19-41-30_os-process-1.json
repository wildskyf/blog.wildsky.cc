{
  "guid": "http://blog.wildsky.cc/?p=63",
  "date": "2019-06-06T19:41:30",
  "slug": "os-process-1",
  "link": "/posts/os-process-1/",
  "title": "作業系統 Ch3 &#8211; Process (上）",
  "excerpt": "<p>因為篇幅有點長，所以這一章節我分成上下兩篇文來寫。本篇會包含這些： Process vs Program Th&#8230;</p>\n",
  "feature_image_url": "https://backend.wildsky.cc/wp-content/uploads/2019/06/slogan_bg-e1559891275485.png",
  "content": "\n<p>因為篇幅有點長，所以這一章節我分成上下兩篇文來寫。本篇會包含這些：</p>\n\n\n\n<ul><li>Process vs Program</li><li>Thread</li><li>Process State</li><li>Process Control Block</li><li>Context Switch</li></ul>\n\n\n\n<!--more-->\n\n\n\n<h2>Process vs Program</h2>\n\n\n\n<p>什麼是 Process？和 Program 差在哪？</p>\n\n\n\n<ul><li>Program = passive entity &#8211; 只是存在 disk 的 binary 檔</li><li>Process = active entity &#8211; 存在 memory 中、正在執行的 program</li></ul>\n\n\n\n<p>簡單地說，差別就是在是否「正在被執行」。</p>\n\n\n\n<p>一個 Process 包含了：</p>\n\n\n\n<ol><li>code segment (text section) =&gt; 不是一般的 code，是 instruction</li><li>data section =&gt; 這裡放 global variable</li><li>stack =&gt; 這裡放 local variable，因為用完可以直接 pop 掉</li><li>heap =&gt; 動態分配記憶體空間給變數或 class 時會用到的</li><li>current activity (program counter, register counter)</li><li>相關資源的 set（e.g., open file handlers）</li></ol>\n\n\n\n<p>2,3,4 就是寫程式時用到的變數，</p>\n\n\n\n<p>一個 process 可用的 memory 是有限的，所以如果遞迴 call 太多層或是 allocate 太多記憶體，都會跟你說 out of memory，因為 memory 的使用量是有上限的。</p>\n\n\n\n<h2>Thread</h2>\n\n\n\n<ul><li>thread 也稱為 lightweight process</li><li>內容物與 process 相同</li><li>不同之處為，多個 thread 間可以共用某一塊 memory</li><li>因為 thread 的 parent process 在 create thread 時就會做空間的管理<br>→ 所以就省掉了部分空間管理的程式處理<br>→ 所以是 lightweight</li><li>thread 是使用 CPU 的最小單位</li><li>同一個 process 下的 thread 可以共用：<ul><li>code section</li><li>data section</li><li>OS resources (open files &amp; signals)</li></ul></li><li>但下面這些是各自獨立：<ul><li>thread ID</li><li>program counter</li><li>register set: 因為 thread 在執行 instruction 時的位置可能不同，執行的狀態也是獨立的</li><li>stack: 各自只摸得到自己的 local variable</li></ul></li></ul>\n\n\n\n<p>之後的章節會再講到更細節，這邊只簡單介紹 Thread 是什麼。</p>\n\n\n\n<h2>Process State</h2>\n\n\n\n<p>介紹 process 在 OS 中的 life cycle，共有五個狀態</p>\n\n\n\n<h3>1- New:</h3>\n\n\n\n<ul><li>把 program load 進記憶體，並在記憶體中把剛剛講的各個 section 都 initialize</li><li>admit: OS 在此時會確認有沒有足夠的資源去 create process，也會看你有沒有權限去執行該 process，都 OK 才會進去 ready</li></ul>\n\n\n\n<h3>2- Ready:</h3>\n\n\n\n<p>OS 是透過 queue 來管理 CPU 資源的競爭，而 process 在 queue 中等著被 CPU 處理的過程就屬於這個狀態。</p>\n\n\n\n<h3>3- Running:</h3>\n\n\n\n<ul><li>進去 CPU 中，正在被執行的狀態</li><li>有可能跑著跑著就被 OS interrupt 回 ready 狀態，因為 OS 要確保他有掌控權，所以會時間一到，就把 CPU switch 給 scheduler</li></ul>\n\n\n\n<h3>4- Waiting:</h3>\n\n\n\n<ul><li>在進行非 CPU 處理時（e.g., I/O），就會進入這個狀態</li><li>等到處理完了，就會回到 ready 等著被 CPU 執行</li><li>雖然在 memory 但是還沒有到能立即被 CPU 執行的狀態</li></ul>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"/wp-content/uploads/2018/os-process-state-diagram.png\" alt=\"Process State 的流程圖\"/></figure>\n\n\n\n<h2>Process Control Block</h2>\n\n\n\n<p>在 memory 中，用來記錄剛剛那些資訊的 Table。</p>\n\n\n\n<p>當 process 被 create 時，OS 就會幫他建一個 table 叫做 PCB，裡面存著一些 process 在執行中的狀態的相關資訊，比較重要的是：</p>\n\n\n\n<ol><li>指到 queue 的下一個 PCB 的 <strong>pointer</strong>：當我們說「把 process 放進 queue」時，其實是把 PCB 放進去，而這邊的資料結構是 Linked list，就需要 pointer 來指到 queue 中的下一個 PCB</li><li><strong>process state</strong>: 記錄 process 的當前狀態</li><li>Program counter</li><li>CPU register</li></ol>\n\n\n\n<p>這些東西是放在 memory，而且是 <strong>kernel space</strong> 的地方，由 OS 進行處理。</p>\n\n\n\n<p>其他還有</p>\n\n\n\n<ol><li>CPU scheduling information (e.g., priority)</li><li>memory management information (base &amp; limit register): 只有 process 在執行時才會把這兩個值從 memory load 進 CPU 的 register。</li><li>I/O status/information</li><li>accounting information</li></ol>\n\n\n\n<h2>Context Switch</h2>\n\n\n\n<p>定義：把 CPU 上正在執行的 process，switch 成另外一個 process 的動作就叫做 context switch。</p>\n\n\n\n<p>CPU 中的程式在切換的流程如下：</p>\n\n\n\n<ol><li>process p0 正在 CPU 中被執行</li><li>出現一個 interrupt，p0 就要準備進入 idle</li><li>進行 Context Switch:<ol><li>把 CPU 中 p0 的狀態 load 進 PCB0</li><li>load PCB1（即將被切換到的 process1 的 PCB）</li><li>context switch 完成</li></ol></li><li>開始執行 p1<ul><li>context switch 是 overhead（因為在 switch 時，其實是在浪費 CPU）</li><li>但因為很常需要 switch，所以我們能做的只有盡可能地<strong>縮短時間</strong>，而這與下列這些事情相關：<ul><li>memory 的速度</li><li>register 的數量（越少的話需要存取的數量就少）</li><li>合併 load &amp; save PCB 的 instruction，讓他一次做完</li><li>硬體支援：提供多組 set 的 register，讓他不用在 register 和 memory 之間切換</li></ul></li></ul></li></ol>\n\n\n\n<p>關於 Process 的後續講解，請見 <a href=\"http://blog.wildsky.cc/posts/os-process-2/\">Process（下）</a> 這篇文章</p>\n\n\n\n<h2>Ref</h2>\n\n\n\n<ul><li><a href=\"http://ocw.nthu.edu.tw/ocw/index.php?page=chapter&amp;cid=141&amp;chid=1845&amp;video_url=http%3A%2F%2Focw.nthu.edu.tw%2Fvideosite%2Findex.php%3Fop%3Dwatch%26id%3D3936%26filename%3D1920_1080_3072.MP4%26type%3Dview%26cid%3D141%26chid%3D1845\">第六講第二節</a></li><li><a href=\"http://ocw.nthu.edu.tw/ocw/index.php?page=chapter&amp;cid=141&amp;chid=1846&amp;video_url=http%3A%2F%2Focw.nthu.edu.tw%2Fvideosite%2Findex.php%3Fop%3Dwatch%26id%3D3937%26filename%3D1920_1080_3072.MP4%26type%3Dview%26cid%3D141%26chid%3D1846\">第七講第一節</a></li></ul>\n"
}