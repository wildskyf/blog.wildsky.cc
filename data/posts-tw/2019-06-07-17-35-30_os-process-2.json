{
  "guid": "http://blog.wildsky.cc/?p=1026",
  "date": "2019-06-07T17:35:30",
  "slug": "os-process-2",
  "link": "/posts/os-process-2/",
  "title": "作業系統 Ch3 &#8211; Process (下）",
  "excerpt": "<p>本章節承接 Process（上），會繼續談到下列這些東西： process scheduling proces&#8230;</p>\n",
  "feature_image_url": "https://backend.wildsky.cc/wp-content/uploads/2019/06/slogan_bg-e1559891275485.png",
  "content": "\n<p>本章節承接 <a href=\"http://blog.wildsky.cc/posts/os-process-1/\">Process（上）</a>，會繼續談到下列這些東西：</p>\n\n\n\n<ul><li>process scheduling</li><li>process scheduling queue</li><li>Inter-process Communication<ul><li>Share Memory</li><li>Message Passing</li></ul></li></ul>\n\n\n\n<!--more-->\n\n\n\n<h2>Process Scheduling 的概念</h2>\n\n\n\n<h3>目的</h3>\n\n\n\n<ul><li>Multi-programming: 最大化 CPU 的產能（utilization）</li><li>Time sharing: 因為程式是 <strong>輪流</strong> 去使用 CPU 的，所以誰先誰後就是 scheduler要處理的事情。</li></ul>\n\n\n\n<h3>Process Scheduling Queue</h3>\n\n\n\n<ul><li>Job queue: 發生在 New State</li><li>Ready queue: 發生在 Ready state，等著使用 CPU</li><li>Device queue: 發生在 Wait State，等著使用 I/O</li></ul>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"/wp-content/uploads/2018/process-scheduling-diagram.png\" alt=\"process scheduling diagram\"/></figure>\n\n\n\n<h3>scheduler</h3>\n\n\n\n<p>scheduler 根據「即將被處理」的對象不同會有不同的 scheduler，像是 CPU scheduler、Job scheduler 之類的。</p>\n\n\n\n<ul><li>short-term scheduler<ul><li>CPU scheduler 又被稱為 short-term scheduler，因為執行的頻率較高</li><li>Ready State -&gt; Run State</li></ul></li><li>long-term scheduler<ul><li>Job scheduler。相較於 CPU 的頻率來看，Job scheduler 的執行的頻率較低</li><li>有新的程式被執行，要產生 process 時才會執行的 scheduler。</li><li>主要是人的行為觸發。</li><li>New State -&gt;  Ready State</li></ul></li><li>Medium-term scheduler<ul><li>把 program 從 memory swap 回 disk 成 memory content（和之後會講到的 virtual memory 有關）</li><li>Ready State -&gt; Wait State</li></ul></li></ul>\n\n\n\n<h4>short-term scheduler</h4>\n\n\n\n<ul><li>執行頻率很高（e.g., once per 100ms ）<ul><li>所以執行的效率就必須要很高</li></ul></li><li>要想演算法來縮短每個 process 的等待時間（還要在意 fairness）</li><li>又因為效率要高，所以也不能太複雜（不然 CPU overhead 就會太高）<ul><li>overehad = (選的時間) / (執行 job 的時間 + 選的時間)</li></ul></li></ul>\n\n\n\n<h4>long-term scheduler</h4>\n\n\n\n<ul><li>控制 <strong>degree of multi-programming</strong><ul><li>degree of multi-programming 指的是「目前電腦上，有多少程式在 memory 中」</li><li>太低的話，CPU 就會有很大的時間在 idle</li><li>太高的話，就會發生 trashing。很多程式在搶 memory，會一直做 swap、不斷地做 I/O。</li></ul></li><li>負責讓 CPU &amp; I/O 有最高的產能：所以就要混著讓做 CPU &amp; 做 I/O 的程式進來</li></ul>\n\n\n\n<h4>medium-term scheduler</h4>\n\n\n\n<p>處理程式在 memory &amp; disk 之間切換的 scheduler，現在電腦因為 memory 比較夠、且有 virtual memory 的概念，所以 long-term scheduler 比較式微，其工作相較過往，都會比較落在 medium-term scheduler 身上。</p>\n\n\n\n<ul><li><strong>swap out</strong>: 把 process 從 memory 搬回 disk 上來減少 degree of multi-programming</li><li><strong>swap in</strong>: 發現 memory 有空間了，就把 process 從 disk 抓回 memory</li><li>propose:<ul><li>improve process mix：控制 CPU &amp; I/O bound</li><li>free up memory</li></ul></li></ul>\n\n\n\n<h2>Inter-process Communication (IPC)</h2>\n\n\n\n<ul><li>定義：在一或多個 Process 或 Thread 之間，用來溝通的方法</li><li>種類<ul><li>不溝通的：independent process</li><li>會溝通的：cooperating process</li></ul></li><li>目的<ul><li>資訊共享</li><li>加速運算（平行運算）</li><li>方便</li><li>modularity（e.g. micro-kernel）</li></ul></li></ul>\n\n\n\n<h2>How-to IPC</h2>\n\n\n\n<p>要做到 IPC 有兩種方式：</p>\n\n\n\n<ul><li>share memory<ul><li>user synchronization 要更小心謹慎（處理這個最痛苦啊）</li><li>好處就是快</li><li>透過 memory 的 address</li></ul></li><li>message passing<ul><li>需要 system call，所以通常較慢</li><li>但若資料小，用這個方法的話可以省去 share memory 的 lock 之類的額外資源消耗，反而會略快（且不用在意 sync 的問題）</li></ul></li></ul>\n\n\n\n<h3>Share Memory</h3>\n\n\n\n<ul><li>要知道怎麼 create 一個可以共用的 memory 區塊<ul><li>預設是不會發生，因為 OS 要確保 process 的 protection</li></ul></li><li>開空間要呼叫 system call</li><li>但資料格式都是一堆 bytes，由 process 自行定義、處理</li><li>必須確保不會同時有兩個對同一塊 memory 進行寫入的 access 行為</li></ul>\n\n\n\n<p>這邊周老師舉了個 consumer &amp; producer 的例子，不使用 locking 的話會需要犧牲一塊空間來做到 synchronization。</p>\n\n\n\n<h3>Message Passing</h3>\n\n\n\n<p>好處</p>\n\n\n\n<ul><li>通常內含 synchronize 的機制，programmer 不用擔心這件事</li><li>可以自行掌控各個 variable，不用擔心被別人亂竄改</li></ul>\n\n\n\n<p>方式有兩種：</p>\n\n\n\n<ul><li>Sockets<ul><li>network 中的 IP/port，IP 就是電腦，port 就是 process</li><li>資料格式就是 stream of bytes</li></ul></li><li>Remote Procedure Calls<ul><li>使用遠端提供的 function call 去做到資料的傳輸</li><li>輸入輸出會有預先定義好的資料格式</li></ul></li></ul>\n\n\n\n<p>一般來說，OS 會提供兩種 function 讓程式之間可以 Call，並在背後做各種 memory copy 的處理。</p>\n\n\n\n<ul><li>send(Message)</li><li>receive(Message)</li></ul>\n\n\n\n<p>而整個 communication system 還會需要提供一個 link，以便可以溝通，這個 Link 又會分為兩類：</p>\n\n\n\n<ul><li>Physical<ul><li>是透過 network 還是 HW bus，甚至是 shared memory 等等的做法</li></ul></li><li>Logical<ul><li>direct / indirect：要否指定接收對象</li><li>方向性：只能 A 傳 B，B 不能傳 A</li><li>角色是否相對</li></ul><ul><li><strong>Blocking / non-blocking</strong>：行為做完才會回傳 or not</li><li>send by copy or by reference</li><li>固定大小 / 可變大小 的 message</li></ul></li></ul>\n\n\n\n<h4>Direct V.S Indirect Message Passing</h4>\n\n\n\n<h5>Direct</h5>\n\n\n\n<ul><li>send &amp; receive 的 params 中就需要有對方的 identity</li><li>可以不用 init</li><li>一定是 1 to 1</li><li>modularity 有限</li></ul>\n\n\n\n<h5>Indirect</h5>\n\n\n\n<ul><li>會有一個 mailbox，要傳的人會把東西丟進去，要拿的人再跟 mailbox 拿</li><li>sender &amp; receiver 都不用在意對方是誰</li><li>connection 需要由 programmer 建立</li><li>可以多對多</li><li>處理 message 的管理的人會是另一個程式，而非收送雙方，Mailbox 可以是 by OS 或 by process</li><li>Issue: 可能會有個人同時跟 mailbox 拿資料，理論上一個 msg 應該只有一個人拿得到，所以下面就有幾個解法<ul><li>只允許一個 receiver（最爛，根本就是 direct）</li><li>用 Locking 的方式，確保同一時間只有一個 receiver</li><li>交給 mailbox 決定，會分為兩步驟。receiver 會先要求要取值，而 mailbox 決定要給誰之後再去跟 receiver 說有沒有拿到。</li></ul></li></ul>\n\n\n\n<h4>Blocking V.S non-Blocking</h4>\n\n\n\n<ul><li>blocking -> synchronous</li><li>non-blocking -> asynchronous</li></ul>\n\n\n\n<table class=\"wp-block-table\"><tbody><tr><td></td><td>Blocking</td><td>non-Blocking</td></tr><tr><td>Send</td><td>確定對方接到後才會 return</td><td>送出後就不管</td></tr><tr><td>Receive</td><td>拿到 Message 才會 return</td><td>Call 完後就不管。<br>通常會拿到一個 token，<br>之後確認有拿到後<br>再用 callback function 去處理它</td></tr></tbody></table>\n\n\n\n<h5>Buffer 與此兩種之間的關係</h5>\n\n\n\n<ul><li>Blocking 通常會有 size=1 的 buffer，用來 check 是否完成行為。（未完成就一個擋著）</li><li>Non-blocking 則有兩種情況<ul><li>bounded: 送到滿了之後就會 blocking，或是 throw 一個 error</li><li>unbounded: 不管，就是送到整個 OS 都滿了才會不給送</li></ul></li></ul>\n\n\n\n<h3>Socket</h3>\n\n\n\n<ul><li>會有 client &amp; server</li><li>server 要先打開 client 才能連</li><li>client 進行 connect 之後，就可以盡情 read / write</li><li>補充：<ul><li>server 在 accept 之後，會動態開 thread，如此才能一次處理多個 request</li></ul></li></ul>\n\n\n\n<h3>Remote Procedure Calls (RPC)</h3>\n\n\n\n<ul><li>Library 通常會有 stubs，在 client 端和 server 端會各有一隻小程式，（server 端的叫 skeleton）會負責 implement 細節</li><li>其實通常下面也可能用 socket，只是幫 programmer 包起來而已</li><li>parameter mashaling<ul><li>把 params 包進 message 就叫 </li></ul><ul><li>要把兩台電腦串在一起其實有許多細節要處理，RPC 就要負責幫使用者把這些繁瑣的事情解決掉</li></ul></li></ul>\n\n\n\n<h2>Ref</h2>\n\n\n\n<ul><li><a href=\"http://ocw.nthu.edu.tw/ocw/index.php?page=chapter&amp;cid=141&amp;chid=1846&amp;video_url=http%3A%2F%2Focw.nthu.edu.tw%2Fvideosite%2Findex.php%3Fop%3Dwatch%26id%3D3938%26filename%3D1920_1080_3072.MP4%26type%3Dview%26cid%3D141%26chid%3D1846\">第七講第二節</a></li><li><a href=\"http://ocw.nthu.edu.tw/ocw/index.php?page=chapter&amp;cid=141&amp;chid=1852&amp;video_url=http%3A%2F%2Focw.nthu.edu.tw%2Fvideosite%2Findex.php%3Fop%3Dwatch%26id%3D3970%26filename%3D1920_1080_3072.MP4%26type%3Dview%26cid%3D141%26chid%3D1852\">第八講第一節</a></li><li><a href=\"http://ocw.nthu.edu.tw/ocw/index.php?page=chapter&amp;cid=141&amp;chid=1852&amp;video_url=http%3A%2F%2Focw.nthu.edu.tw%2Fvideosite%2Findex.php%3Fop%3Dwatch%26id%3D3973%26filename%3D1920_1080_3072.MP4%26type%3Dview%26cid%3D141%26chid%3D1852\">第八講第二節</a></li><li><a href=\"http://ocw.nthu.edu.tw/ocw/index.php?page=chapter&amp;cid=141&amp;chid=1853&amp;video_url=http%3A%2F%2Focw.nthu.edu.tw%2Fvideosite%2Findex.php%3Fop%3Dwatch%26id%3D3974%26filename%3D1920_1080_3072.MP4%26type%3Dview%26cid%3D141%26chid%3D1853\">第九講第一節</a></li><li><a href=\"http://ocw.nthu.edu.tw/ocw/index.php?page=chapter&amp;cid=141&amp;chid=1853&amp;video_url=http%3A%2F%2Focw.nthu.edu.tw%2Fvideosite%2Findex.php%3Fop%3Dwatch%26id%3D3975%26filename%3D1920_1080_3072.MP4%26type%3Dview%26cid%3D141%26chid%3D1853\">第九講第二節</a></li></ul>\n"
}