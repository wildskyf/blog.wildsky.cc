{
  "guid": "http://blog.wildsky.cc/?p=167",
  "date": "2018-01-07T16:10:52",
  "slug": "service-worker-intro",
  "link": "/posts/service-worker-intro/",
  "title": "初步理解 Service Worker",
  "excerpt": "<p>Service Wroker（後面簡稱 SW）可以看作是介於瀏覽器、網路、和 Web app 之間的 prox&#8230;</p>\n",
  "feature_image_url": null,
  "content": "\n<p>Service Wroker（後面簡稱 SW）可以看作是介於瀏覽器、網路、和 Web app 之間的 proxy servers。 說穿了就是可以<strong>寫程式來處理 request 和 response 的一種介面</strong>，讓開發者可以藉以增進 offline 時網站的體驗，或是基於網路是否可用來自行決定 web app 應該做出怎樣的行為。其他還有一些<strong>推送通知</strong>或是<strong>背景同步</strong>的功能，標準正在火熱制定中。（寫這篇文章時是 2018/1/7，上次 SPEC 的更新時間是 2017/12/22，應該是去過聖誕節＆跨年了，真好 XD）</p>\n\n\n\n<p>以前的人可能會用&nbsp;<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Using_the_application_cache\">AppCache</a>&nbsp;來做到上述的功能，但他會對你要做的事有很多很多的預期，而如果你的 web app 沒有照著做的話，你就會死得很難看。可以看看這篇：&nbsp;<a href=\"https://alistapart.com/article/application-cache-is-a-douchebag\">https://alistapart.com/article/application-cache-is-a-douchebag</a>。SW 可以解決 AppCache 的問題，你會擁有完全的掌控權，而當這句出現時，就意味著你要寫更多的 Code，用著更複雜的 syntax。人只要活著，一切就都是妥協。</p>\n\n\n\n<!--more-->\n\n\n\n<blockquote class=\"wp-block-quote\"><p>人只要活著，一切就都是妥協。</p></blockquote>\n\n\n\n<p>好啦，不要這麼悲觀。</p>\n\n\n\n<p>Native app 有個很重大的優勢就是可以有離線體驗，而使用 SW 你也可以讓 web app 達成這個夢想。順帶一提，這個叫做&nbsp;<a href=\"http://offlinefirst.org/\">Offline First</a>。許多人選擇 native app 的重大理由之一就是因為這一點，現在 SW 出來應該可以解決這個問題了。（編著：但其他像是效能問題還是沒解決XD）</p>\n\n\n\n<h2 id=\"sw-的用途整理\">SW 的用途整理</h2>\n\n\n\n<ul><li>[主要]&nbsp;<strong>讓網站在沒網路時可用</strong></li><li>可能的其他用法<ul><li>背景資料同步</li><li>回應「從其他 origin 來的」 request</li><li>統一管理那些計算成本很貴的資料，像是<strong>地理資訊</strong>或<strong>陀螺儀資訊</strong>，好讓多個頁面能一起共用這些資訊</li><li>效能提升，預先下載使用者可能需要的資源，像是等等會顯示的圖片之類的</li><li>⋯⋯還有一些其他的黑魔法，會這樣形容是因為我還沒研究到要怎麼實做<ul><li>Client Side 編譯（所以會看到 rust-lang 也有 SW 應該是這個原因）</li><li>背景服務的 Hook</li><li>基於特定網址 pattern 的自定義 templating</li></ul></li><li>其他就等 SPEC 出來再說</li></ul></li></ul>\n\n\n\n<h2 id=\"額外注意\">額外注意</h2>\n\n\n\n<ul><li>SW 沒有 DOM 的存取權限</li><li>完全地 async，非常地 event-driven</li><li>會狂用 promise，建議先學 promise 再學 SW</li><li>SW 一定要在 https 之下才會運作，唯一的例外是 localhost。<ul><li>(localhost is considered a secure origin by browsers as well.)</li></ul></li></ul>\n\n\n\n<h2 id=\"sw-的運作順序\">SW 的運作順序</h2>\n\n\n\n<ol><li>Download</li><li>Install</li><li>Activate</li><li>之後查看有無更新</li><li>有就先下載，但先不 Activate （worker in waiting）</li><li>等到沒有待處理的頁面後，就 Activate（active worker）</li></ol>\n\n\n\n<h2 id=\"開發者要做的事\">開發者要做的事</h2>\n\n\n\n<ol><li>註冊 SW script</li><li>註冊成功後，SW script 就會試著自己安裝自己</li><li>安裝完成後，會觸發&nbsp;<code>install</code>&nbsp;事件，開發者可以利用（開 IndexedDB 然後 cache 資源之類的）<ul><li>聽說有點像 native app 和 firefox OS app 安裝後的味道，但我沒聞過，不知道。</li></ul></li><li>安裝完後就等著被啟用（active），老樣子，這時也會觸發&nbsp;<code>active</code>&nbsp;事件，通常是用來清理前一個版本的 script 的殘餘。</li><li>之後開的頁面就會受到 SW script 掌控，可以用的事件有&nbsp;<code>fetch</code>、<code>sync</code>、<code>push</code></li></ol>\n\n\n\n<p>程式碼部分就先不提，這篇就簡略地介紹 SW 的功用和運作原理就好。</p>\n\n\n\n<h2 id=\"看看自己瀏覽器上的-sw\">看看自己瀏覽器上的 SW</h2>\n\n\n\n<p>如果你是 Firefox，可以直接在網址列輸入&nbsp;<code>about:debugging</code>，左側頁籤選擇 workers， 就會列出許多網站的 SW 囉！聽起來是不是毛毛的呢？XD</p>\n\n\n\n<p>如果你是 chrome，就前往 <code>chrome://inspect/#service-workers</code>，不要再用 chrome 了， 來用用 firefox 吧！（硬要推廣）</p>\n\n\n\n<h2 id=\"參考\">參考</h2>\n\n\n\n<ul><li><a href=\"https://w3c.github.io/ServiceWorker/\">https://w3c.github.io/ServiceWorker/</a></li><li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API\">https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API</a></li><li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers\">https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers</a></li></ul>\n"
}